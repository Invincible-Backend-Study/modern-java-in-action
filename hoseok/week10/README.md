# ğŸ“ŒÂ 19ì¥: í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ê¸°ë²•

**í‚¤ì›Œë“œ**: `ê³ ì°¨ì› í•¨ìˆ˜`, `ì»¤ë§`, `ì˜ì† ìë£Œêµ¬ì¡°`, `ì§€ì—° ë¦¬ìŠ¤íŠ¸`, `íŒ¨í„´ ë§¤ì¹­`, `ì°¸ì¡° íˆ¬ëª…ì„±ì„ ì´ìš©í•œ ìºì‹±`, `ì½¤ë¹„ë„¤ì´í„°`ë¥¼ 

<br><br>

## âœ…Â 19.1 í•¨ìˆ˜ëŠ” ëª¨ë“  ê³³ì— ì¡´ì¬í•œë‹¤

- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°
    - í•¨ìˆ˜, ë©”ì„œë“œê°€ ìˆ˜í•™ì˜ í•¨ìˆ˜ì²˜ëŸ¼ ë¶€ì‘ìš© ì—†ì´ ë™ì‘í•¨ì„ ì˜ë¯¸í•¨
    - í•¨ìˆ˜ë¥¼ ì¼ë°˜ê°’ì²˜ëŸ¼ ì¸ìˆ˜ë¡œ ì „ë‹¬, ê²°ê³¼ë¡œ ë°›ê±°ë‚˜, ìë£Œêµ¬ì¡°ì— ì €ì¥ í•  ìˆ˜ ìˆê²Œí•˜ëŠ” `ì¼ê¸‰ í•¨ìˆ˜` ì·¨ê¸‰
    - Java 8ì˜ ë©”ì„œë“œ ì°¸ì¡°ë¥¼ ì´ìš©í•˜ê±°ë‚˜ ëŒë‹¤ í‘œí˜„ì‹ì„ ì´ìš©í•´ í•¨ìˆ˜ë¥¼ ì¼ê¸‰ ê°ì²´ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
        - ì¼ê¸‰ ê°ì²´: ë³€ìˆ˜ì— í• ë‹¹ ê°€ëŠ¥, ì¸ìë¡œ ì „ë‹¬ ê°€ëŠ¥, í•¨ìˆ˜ì˜ ê²°ê³¼ë¡œ ë¦¬í„´ ê°€ëŠ¥

<br>

### ê³ ì°¨ì› í•¨ìˆ˜

![image](https://github.com/Invincible-Backend-Study/modern-java-in-action/assets/66772624/fc04f984-61bc-4cf4-bb67-453a7d29a52c)


ê³ ì°¨ì› í•¨ìˆ˜ëŠ” ë‹¤ìŒ ì¡°ê±´ì„ ë§Œì¡±í•©ë‹ˆë‹¤.

- í•˜ë‚˜ ì´ìƒì˜ í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ìŒ
- í•¨ìˆ˜ë¥¼ ê²°ê³¼ë¡œ ë°˜í™˜í•¨

Comparator.comaringì´ ê³ ì°¨ì› í•¨ìˆ˜ì˜ ì˜ˆì‹œê°€ ë©ë‹ˆë‹¤.

<br>

### ë¶€ì‘ìš©ê³¼ ê³ ì°¨ì› í•¨ìˆ˜

ë¶€ì‘ìš©: ë¶€ì •í™•í•œ ê²°ê³¼ë‚˜ race conditionì´ ë°œìƒí•˜ëŠ” ìƒí™©

- ê³ ì°¨ì› í•¨ìˆ˜ë‚˜ ë©”ì„œë“œë¥¼ êµ¬í˜„í•  ë•Œ ì–´ë–¤ ì¸ìˆ˜ê°€ ì „ë‹¬ë ì§€ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì¸ìˆ˜ë¡œ ì „ë‹¬í•œ í•¨ìˆ˜ê°€ ë¶€ì‘ìš©ì„ í¬í•¨í•  ê°€ëŠ¥ì„±ì„ ì—¼ë‘ì— ë‘ì–´ì•¼ í•¨
- ì¸ìˆ˜ë¡œ ì „ë‹¬ë„ë‹ˆ í•¨ìˆ˜ê°€ ì–´ë–¤ ë¶€ì‘ìš©ì„ í¬í•¨í•˜ê²Œ ë ì§€ ì •í™•í•˜ê²Œ ë¬¸ì„œí™” í•˜ëŠ”ê²ƒì´ ì¢‹ìŒ

<br>

### ì»¤ë§

- í•¨ìˆ˜ë¥¼ ëª¨ë“ˆí™”í•˜ê³  ì½”ë“œë¥¼ ì¬ì‚¬ìš©í•˜ëŠ”ë° ë„ì›€ì„ ì£¼ëŠ” ê¸°ë²•
- xì™€ yë¼ëŠ” ë‘ ì¸ìˆ˜ë¥¼ ë°›ëŠ” í•¨ìˆ˜ fë¥¼ í•œ ê°œì˜ ì¸ìˆ˜ë¥¼ ë°›ëŠ” gë¼ëŠ” í•¨ìˆ˜ë¡œ ëŒ€ì²´í•˜ëŠ” ê¸°ë²•
gì—­ì‹œ í•˜ë‚˜ì˜ ì¸ìˆ˜ë¥¼ ë°›ëŠ” í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    $f(x, y) = (g(x))(y)$
    

```java
// ì›ë³¸ ë©”ì„œë“œ
static double converter(double x, double f, double b) {
		return x * f + b;
}

// ì»¤ë§ ì ìš©
static DoubleUnaryOperator curriedConverter(double f, double b) {
		return (double x) -> x * f + b;
}
```

<br><br>

## âœ…Â 19.2 ì˜ì† ìë£Œêµ¬ì¡°

ìë£Œêµ¬ì¡°ë¥¼ ê³ ì¹  ìˆ˜ ì—†ëŠ” ìƒí™©ì—ì„œ ìë£Œêµ¬ì¡°ë¡œ í”„ë¡œê·¸ë¨ì„ êµ¬í˜„í•˜ê¸° ìœ„í•œ ìë£Œêµ¬ì¡°ë¡œ DBì—ì„œì˜ ì˜ì†ê³¼ëŠ” ë‹¤ë¥¸ì˜ë¯¸ ì…ë‹ˆë‹¤.

- í•¨ìˆ˜í˜• ë©”ì„œë“œëŠ” ì°¸ì¡° íˆ¬ëª…ì„±ì„ ì§€í‚¤ê¸° ìœ„í•´ ì „ì—­ ìë£Œêµ¬ì¡°ë‚˜ ì¸ìˆ˜ë¡œ ë°›ì€ ìë£Œêµ¬ì¡°ë¥¼ ê°±ì‹ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

<br>

### íŒŒê´´ì ì¸ ê°±ì‹ ê³¼ í•¨ìˆ˜í˜•

```java
class TrainJourney {
		
		public int price;
		public TrainJourney onward;
		
		public TrainJourney(int p, TrainJourney t) {
		  price = p;
		  onward = t;
		}
}

// íŒŒê´´ì ì¸ ê°±ì‹  ì›ë³¸ ë°ì´í„° aê°€ íšŒì†ë¨
static TrainJourney link(TrainJourney a, TrainJourney b) {
    if (a == null) {
        return b;
    }
    TrainJourney t = a;
    while (t.onward != null) {
        t = t.onward;
    }
    t.onward = b;
    return a;
}
```

- ìœ„ì˜ ì½”ë“œëŠ” aì¸ìì˜ ë ì¹¸ì— bë¥¼ ë¶™ì—¬ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ, aì¸ì ìì²´ê°€ ë³€í™”í•˜ê²Œ ë©ë‹ˆë‹¤. ì´ëŸ¬í•œ í˜„ìƒì„ íŒŒê´´ì ì¸ ê°±ì‹ ì´ë¼ ë§í•©ë‹ˆë‹¤.
    - ìœ„ì™€ ê°™ì´ ì£¼ì„ì„ í†µí•´ ì£¼ì˜ì‚¬í•­ì„ ì•Œë ¤ì¤„ ìˆ˜ ìˆì§€ë§Œ ë‚¨ìš©í•˜ê²Œ ëì„ë•ŒëŠ” í›„ì— ìœ ì§€ë³´ìˆ˜í•˜ëŠ” í”„ë¡œê·¸ë˜ë¨¸ë¥¼ ê´´ë¡­í™ë‹ˆë‹¤.

í•¨ìˆ˜í˜•ì—ì„œëŠ” ë©”ì„œë“œë¥¼ ì œí•œí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.

```java
static TrainJourney append(TrainJourney a, TrainJourney b) {
    return a == null ? b : new TrainJourney(a.price, append(a.onward, b));
}
```

- ìœ„ ì½”ë“œëŠ” ì™¸ë¶€ ìë£Œêµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³ , ìƒˆë¡œìš´ TrainJourneyê°ì²´ë¥¼ ìƒì„±í•˜ê³  ì œì¼ ë ì¹¸ì— bë¥¼ ë¶™ì…ë‹ˆë‹¤.
- **ë‹¤ë§Œ ì‚¬ìš©ìëŠ” appendì˜ ê²°ê³¼ë¥¼ ê°±ì‹ í•´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤. (bë¥¼ í›¼ì†í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ)**

ì•„ë˜ ê·¸ë¦¼ì€ íŒŒê´´ì ì¸ ê°±ì‹ ê³¼ ë¹„íŒŒê´´ì ì¸ ê°±ì‹ ì˜ ì½”ë“œë¥¼ ê·¸ë¦¼ìœ¼ë¡œ ë‚˜íƒ€ë‚¸ ê²ƒì…ë‹ˆë‹¤.

![image](https://github.com/Invincible-Backend-Study/modern-java-in-action/assets/66772624/9a9cbd08-bd63-4536-bf8f-53b3b9d1955b)


<br>

### íŠ¸ë¦¬ë¥¼ ì‚¬ìš©í•œ ì˜ˆì œ

```java
static class Tree {

    private String key;
    private int val;
    private Tree left, right;

    public Tree(String k, int v, Tree l, Tree r) {
        key = k;
        val = v;
        left = l;
        right = r;
    }
}

// íŒŒê´´ì ì¸ ê°±ì‹ , ê¸°ì¡´ íŠ¸ë¦¬ tì˜ êµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì—¬ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ì¶”ê°€í•¨
public static Tree update(String k, int newval, Tree t) {
    if (t == null) {
        t = new Tree(k, newval, null, null);
    } else if (k.equals(t.key)) {
        t.val = newval;
    } else if (k.compareTo(t.key) < 0) {
        t.left = update(k, newval, t.left);
    } else {
        t.right = update(k, newval, t.right);
    }
    return t;
}

// í•¨ìˆ˜í˜• ì ‘ê·¼ë²• ì‚¬ìš©
// ë£¨íŠ¸ ë¶€í„° ë…¸ë“œë¥¼ ì‚½ì…í•˜ëŠ” ì§€ì ê¹Œì§€ ê±°ì¹˜ëŠ” ëª¨ë“  ë…¸ë“œë“¤ì„ ìƒˆë¡œ ìƒì„±í•˜ì—¬, ê¸°ì¡´ të¥¼ ë³€ê²½í•˜ì§€ ì•ŠìŒ
public static Tree fupdate(String k, int newval, Tree t) {
    return (t == null) ?
            new Tree(k, newval, null, null) :
            k.equals(t.key) ?
                    new Tree(k, newval, t.left, t.right) :
                    k.compareTo(t.key) < 0 ?
                            new Tree(t.key, t.val, fupdate(k, newval, t.left), t.right) :
                            new Tree(t.key, t.val, t.left, fupdate(k, newval, t.right));
}
```

- fupdateëŠ” ê¸°ì¡´ì˜ êµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³  ìƒˆë¡œìš´ íŠ¸ë¦¬ë¥¼ ë§Œë“­ë‹ˆë‹¤. â†’ ìˆœìˆ˜í•œ í•¨ìˆ˜í˜•
- ì´ëŸ° í•¨ìˆ˜í˜• ìë£Œêµ¬ì¡°ë¥¼ `ì˜ì†`ì´ë¼ê³  í•˜ë©° ì˜ì†ì˜ ì˜ë¯¸ëŠ” `ì €ì¥ëœ ê°’ì´ ë‹¤ë¥¸ ëˆ„êµ°ê°€ì— ì˜í•´ ì˜í–¥ì„ ë°›ì§€ ì•ŠëŠ” ìƒíƒœë¥¼ ë§í•©ë‹ˆë‹¤.`
- **ë‹¤ë§Œ ê±°ì¹˜ì§€ ì•ŠëŠ”ê³³ì€ ê¸°ì¡´ì˜ ë…¸ë“œë¥¼ ì¬ì‚¬ìš©í•˜ë¯€ë¡œ í”„ë¡œê·¸ë˜ë¨¸ëŠ” ë°˜í™˜ ìë£Œêµ¬ì¡°ë¥¼ ìˆ˜ì •í•˜ë©´ ì•ˆë©ë‹ˆë‹¤.**
- Treeì˜ í•„ë“œë“¤ì„ finalë¡œ ë‘ì–´ ê¸°ì¡´ êµ¬ì¡°ë¥¼ ë³€í™”ì‹œí‚¤ì§€ ì•Šê² ë‹¤ê³  ì§ì ‘ì ìœ¼ë¡œ ì„ ì–¸í•  ìˆ˜ ë„ ìˆìŠµë‹ˆë‹¤.

<br><br>

## âœ…Â 19.3 ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•˜ëŠ” ì§€ì—° í‰ê°€

ìŠ¤íŠ¸ë¦¼ì€ ë‹¨ í•œ ë²ˆë§Œ ì†Œë¹„í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¬ê·€ì ìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

ì´ëŸ¬í•œ ì œì•½ìœ¼ë¡œ ë°œìƒí•˜ëŠ” ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.

<br>

### ìê¸° ì •ì˜ ìŠ¤íŠ¸ë¦¼

ì†Œìˆ˜ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì¤‘ì—ì„œ ëŒ€í‘œì ì¸ ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ê°€ ìˆìŠµë‹ˆë‹¤.

- 2ë¥¼ ì œì™¸í•œ ëª¨ë“  2ì˜ ë°°ìˆ˜ë“¤ì€ ì‚­ì œ
- ì œê±°ë˜ì§€ ì•Šì€ ë‹¤ìŒìˆ«ìì¸ 3ì˜ ë°°ìˆ˜ë“¤ì„ ì‚­ì œ
- ì œê±°ë˜ì§€ ì•Šì€ ë‹¤ìŒìˆ«ìì¸ 5ì˜ ë°°ìˆ˜ë“¤ì„ ì‚­ì œ

ìœ„ ê³¼ì •ì„ ë°˜ë³µí•˜ë©´ì„œ ì†Œìˆ˜ë¥¼ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ë¥¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```java
public static void main(String[] args) {
    IntStream range = IntStream.range(1, 101);
    primes(range, 100);
}

static IntStream primes(IntStream numbers, int n) {
    if (n == 0) {
        return IntStream.empty(); // No more primes to find
    }

    int head = head(numbers);
    return IntStream.concat(
            IntStream.of(head),
            primes(tail(numbers).filter(num -> num % head != 0), n - 1)
    );
}

private static IntStream tail(final IntStream numbers) {
    return numbers.skip(1);
}

private static int head(final IntStream numbers) {
    IntStream limit = numbers.limit(1);
    return limit.findFirst().getAsInt();
}
```

- í•˜ì§€ë§Œ headì—ì„œ numbers ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ ì†Œë¹„í•˜ê³ , tailì—ì„œ ì†Œë¹„ëœ numbersì— ëŒ€í•´ ì—°ì‚°ì„ í•˜ë¯€ë¡œ
`stream has already been operated upon or closes`ë¼ëŠ” ì˜ˆì™¸ ë©”ì‹œì§€ê°€ ë°œìƒí•©ë‹ˆë‹¤.
- ë˜í•œ ë‘ ë²ˆì§¸ ì¸ìˆ˜ì¸ primesë¥¼ ì§ì ‘ ì¬ê·€í˜¸ì¶œí•˜ë©° ë¬´í•œ ì¬ê·€ì— ë¹ ì§€ê²Œ ë©ë‹ˆë‹¤. ì´ëŠ” concatì˜ ë‘ë²ˆì§¸ ì¸ìˆ˜ë¥¼ ì§€ì—° í‰ê°€í•˜ì—¬ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    - ì¦‰, ì†Œìˆ˜ë¥¼ ì²˜ë¦¬í•  í•„ìš”ê°€ ìˆì„ë•Œë§Œ ìŠ¤íŠ¸ë¦¼ì„ ì‹¤ì œë¡œ í‰ê°€ í•©ë‹ˆë‹¤.

<br>

### ì§€ì—° ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°

```java
interface MyList<T> {

    T head();

    MyList<T> tail();

    default boolean isEmpty() {
        return true;
    }

    MyList<T> filter(Predicate<T> p);

}

class LazyList<T> implements MyList<T> {

    final T head;
    final Supplier<MyList<T>> tail;

    public LazyList(T head, Supplier<MyList<T>> tail) {
        this.head = head;
        this.tail = tail;
    }

    @Override
    public T head() {
        return head;
    }

    @Override
    public MyList<T> tail() {
        return tail.get();
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    *@Override
    public MyList<T> filter(Predicate<T> p) {
        return isEmpty() ? this
                : p.test(head()) ? new LazyList<>(head(), () -> tail().filter(p)) : tail().filter(p);
    }*

}

public static LazyList<Integer> from(int n) {
    return new LazyList<Integer>(n, () -> from(n + 1));
}

// ì‹¤ì œ ì‚¬ìš©
LazyList<Integer> numbers = from(2);
int two = numbers.head();
int three = numbers.tail().head();
int four = numbers.tail().tail().head();
System.out.println(two + " " + three + " " + four);
// 1, 2, 3
```

- ìˆ«ìë¥¼ 1ì”© ì¦ê°€í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ìƒì„±í•˜ì§€ë§Œ, Supplier ë•ë¶„ì— í˜¸ì¶œí•˜ê¸° ì „ê¹Œì§€ ì¬ê·€ ë™ì‘ì„ ì§€ì—°ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì¬ê·€ë¡œ ë™ì¼ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë¯€ë¡œ ê²°êµ­ í˜¸ì¶œ íšŸìˆ˜ë§ˆë‹¤ ì¬ê·€ê°€ ëŒê²Œ ë˜ì–´ ë¬´í•œëŒ€ì˜ ì§€ì—° ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì§€ì—° ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ ì†Œìˆ˜ë¥¼ ìƒì„±í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```java
public static MyList<Integer> primes(MyList<Integer> numbers) {
    return new LazyList<>(numbers.head(), () -> primes(numbers.tail().filter(n -> n % numbers.head() != 0)));
}

numbers = from(2);
int prime_two = primes(numbers).head();
int prime_three = primes(numbers).head();
int prime_five = primes(numbers).tail().tail().head();
System.out.println(prime_two + " " + prime_three + " " + prime_five);
// 2, 3, 5 ì¶œë ¥
```

- primesê°€ ë°˜í™˜í•˜ëŠ” LazyList ê°ì²´ì˜ tailì„ primesë©”ì„œë“œë¡œ ê°ì‹¸ì ¸ ìˆìœ¼ë©° ë‚´ë¶€ì ìœ¼ë¡œ filteringì„ í†µí•´ ë°°ìˆ˜ëŠ” ê±°ë¥´ëŠ” ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
- filterì—ì„  Predicateê°€ ì°¸ì´ë¼ë©´ ì§€ì—° ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ì—¬ ë°˜í™˜í•˜ì§€ë§Œ, ê±°ì§“ì´ë¼ë©´ í•´ë‹¹ ìˆ«ìëŠ” ì†Œìˆ˜ê°€ ì•„ë‹ˆë¯€ë¡œ ì¦‰ì‹œ ì—°ì‚°ìœ¼ë¡œ ìˆ«ìë¥¼ ì¦ê°€ì‹œí‚¤ê³  ì¬ê·€ë¥¼ ëŒì•„ ë°°ìˆ˜ê°€ ì•„ë‹Œ ìˆ«ìê°€ ë‚˜ì˜¬ë•Œê¹Œì§€ í•„í„°ë§ í•©ë‹ˆë‹¤.

í•˜ì§€ë§Œ ìœ„ì˜ êµ¬ì¡°ëŠ” ëª‡ê°€ì§€ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.

- ìë£Œêµ¬ì¡°ì˜ 10% ë¯¸ë§Œì˜ ë°ì´í„°ë¥¼ í™œìš©í•˜ëŠ” ìƒí™©ì—ì„œ ì§€ì—° ì‹¤í–‰ì— ì˜í•œ ì˜¤ë²„í—¤ë“œê°€ ë” í¬ë‹¤.
- LazyListê°’ì´ ì§„ì§œë¡œ ê²Œìœ¼ë¥´ì§€ ì•Šë‹¤ â†’ LazyListê°’ì„ tail()ì„ ì´ìš©í•´ íƒìƒ‰í• ë•Œ ê° ë…¸ë“œë“¤ì´ ë‘ ê°œì”© ìƒì„±ë¨
    - ì²˜ìŒ tail() í˜¸ì¶œë§Œ Supplierê°€ í˜¸ì¶œë˜ë„ë¡í•˜ê³  ê²°ê³¼ê°’ì„ ìºì‹œí•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<br><br>

## âœ…Â 19.4 íŒ¨í„´ ë§¤ì¹­

ìˆ˜í•™ì€ ë‹¤ìŒê³¼ ê°™ì€ ì •ì˜ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

$f(0) = 1$, $f(n) = n * f(n - 1)$

ì´ë¥¼ ìë°”ë¡œ êµ¬í˜„í•˜ê¸° ìœ„í•´ì„  if-then-else í˜¹ì€ switchë¥¼ í†µí•´ êµ¬í˜„í•´ì•¼ í•˜ëŠ”ë° ì´ëŠ” ìˆœìˆ˜í•œ ë¡œì§ì„ ì œì™¸í•œ ì½”ë“œì˜ ì–‘ì´ ë§ì•„ì§€ê²Œ ë©ë‹ˆë‹¤.

ìë°”ëŠ” íŒ¨í„´ ë§¤ì¹­ ê¸°ëŠ¥ì´ ì—†ì§€ë§Œ ë¹„ìŠ·í•˜ê²Œ êµ¬í˜„í•˜ì—¬ ë¶ˆí•„ìš”í•œ ì½”ë“œë“¤ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<br>

### ë°©ë¬¸ì ë””ìì¸ íŒ¨í„´

visitor design patternì€ ìë£Œí˜•ì„ unwrapí•  ìˆ˜ ìˆëŠ” íŒ¨í„´ì…ë‹ˆë‹¤. 

ì´ëŠ” íŠ¹ì • ë°ì´í„° í˜•ì‹ì„ ë°©ë¬¸í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ìº¡ìŠí™” í•˜ëŠ” í´ë˜ìŠ¤ë¥¼ ë”°ë¡œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
class BinOp extends Expr {

		public Expr accept(SimplifyExprVisitor v) {
				return v.visit(this);
		}
}

class SimplifyExprVisitor {
		
		public Expr visit(BinOp e) {
				if ("+".equals(e.opname) && e.right instanceof Number && ...) {
							return e.left;
				}
		}
		return e;
}
```

ìœ„ì™€ ê°™ì´ BinOpì˜ acceptì˜ ì¸ìˆ˜ì¸ SimplifyExprVisitorì—ê²Œ ìê¸° ìì‹ ì„ ë„˜ê²¨ì£¼ì–´ unwrapí•©ë‹ˆë‹¤.

<br>

### íŒ¨í„´ ë§¤ì¹­ì˜ í˜

ìŠ¤ì¹¼ë¼ëŠ” íŒ¨í„´ ë§¤ì¹­ì„ ì§€ì›í•˜ëŠ” ì–¸ì–´ë¡œ ê°€ì¥ í° íŠ¹ì§•ì€ ì•„ì£¼ ì»¤ë‹¤ë€ switchë¬¸, if-then-elseë¬¸ì„ í”¼í•  ìˆ˜ ìˆë‹¤ëŠ” ì‚¬ì‹¤ì…ë‹ˆë‹¤.

ìë°” 8ì˜ ëŒë‹¤ë¥¼ ì´ìš©í•´ íŒ¨í„´ ë§¤ì¹­ê³¼ ë¹„ìŠ·í•œ ì½”ë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
// íŒ¨í„´ ë§¤ì¹­ì— ì‚¬ìš©ë˜ëŠ” í´ë˜ìŠ¤ë“¤
class Expr {
}

class Number extends Expr {

    int val;

    public Number(int val) {
        this.val = val;
    }

    @Override
    public String toString() {
        return "" + val;
    }

}

class BinOp extends Expr {

    String opname;
    Expr left, right;

    public BinOp(String opname, Expr left, Expr right) {
        this.opname = opname;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return "(" + left + " " + opname + " " + right + ")";
    }

}

interface TriFunction<S, T, U, R> {
    R apply(S s, T t, U u);
}
```

```java
public class PatternMatching {

    public static void main(String[] args) {
        Expr e1 = new BinOp("+", new Number(5), new Number(0));
        Expr simplify = simplify(e1);
        System.out.println(simplify);

        Expr e2 = new BinOp("+", new Number(5), new BinOp("*", new Number(3), new Number(4)));
        Integer result = evaluate(e2);
        System.out.println(e2 + " = " + result);
    }

		// ê°„ë‹¨í•œ íŒ¨í„´ ë§¤ì¹­
    private static Expr simplify(Expr e) {
        TriFunction<String, Expr, Expr, Expr> binopcase = (opname, left, right) -> {
            if ("+".equals(opname)) {
                if (left instanceof Number && ((Number) left).val == 0) {
                    return right;
                }
                if (right instanceof Number && ((Number) right).val == 0) {
                    return left;
                }
            }
            if ("*".equals(opname)) {
                if (left instanceof Number && ((Number) left).val == 1) {
                    return right;
                }
                if (right instanceof Number && ((Number) right).val == 1) {
                    return left;
                }
            }
            return new BinOp(opname, left, right);
        };
        Function<Integer, Expr> numcase = val -> new Number(val);
        Supplier<Expr> defaultcase = () -> new Number(0);

        return patternMatchExpr(e, binopcase, numcase, defaultcase);
    }

		// ì‹¤ì œ ëª¨ë“  ê²½ìš° ì…ë ¥ì— ëŒ€í•˜ì—¬ ë§ì…ˆ, ê³±ì…ˆì„ ì •ì˜í•¨
    private static Integer evaluate(Expr e) {
        Function<Integer, Integer> numcase = val -> val;
        Supplier<Integer> defaultcase = () -> 0;
        TriFunction<String, Expr, Expr, Integer> binopcase = (opname, left, right) -> {
            if ("+".equals(opname)) {
                if (left instanceof Number && right instanceof Number) {
                    return ((Number) left).val + ((Number) right).val;
                }
                if (right instanceof Number && left instanceof BinOp) {
                    return ((Number) right).val + evaluate(left);
                }
                if (left instanceof Number && right instanceof BinOp) {
                    return ((Number) left).val + evaluate(right);
                }
                if (left instanceof BinOp && right instanceof BinOp) {
                    return evaluate(left) + evaluate(right);
                }
            }
            if ("*".equals(opname)) {
                if (left instanceof Number && right instanceof Number) {
                    return ((Number) left).val * ((Number) right).val;
                }
                if (right instanceof Number && left instanceof BinOp) {
                    return ((Number) right).val * evaluate(left);
                }
                if (left instanceof Number && right instanceof BinOp) {
                    return ((Number) left).val * evaluate(right);
                }
                if (left instanceof BinOp && right instanceof BinOp) {
                    return evaluate(left) * evaluate(right);
                }
            }
            return defaultcase.get();
        };

        return patternMatchExpr(e, binopcase, numcase, defaultcase);
    }

    static T patternMatchExpr(Expr e, TriFunction<String, Expr, Expr, T> binopcase, Function<Integer, T> numcase,
                                  Supplier<T> defaultcase) {
        if (e instanceof BinOp) {
            return binopcase.apply(((BinOp) e).opname, ((BinOp) e).left, ((BinOp) e).right);
        } else if (e instanceof Number) {
            return numcase.apply(((Number) e).val);
        } else {
            return defaultcase.get();
        }
    }

}
```

```java
T patternMatchExpr(Expr e, TriFunction<String, Expr, Expr, T> binopcase, Function<Integer, T> numcase, Supplier<T> defaultcase)
```

- `binopcase`: ì—°ì‚°ì‹ì„ ê³„ì‚°í•˜ê¸° ìœ„í•´ ì •ì˜í•œ TriFunction íƒ€ì…
- `numcase`: ë‹¨ìˆœ ìˆ«ìê°€ ì…ë ¥ëì„ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜í•˜ê¸° ìœ„í•œ Function íƒ€ì…
- `defaultcase`: BinOp, Number íƒ€ì…ì´ ì•„ë‹Œ ê²½ìš° ì‹¤í–‰ë˜ëŠ” ê¸°ë³¸ê°’ ë°˜í™˜ Supplier íƒ€ì…

<br><br>

## âœ…Â 19.5 ê¸°íƒ€ ì •ë³´

### ìºì‹± ë˜ëŠ” ê¸°ì–µí™”

- ì°¸ì¡° íˆ¬ëª…ì„±ì´ ìœ ì§€ë˜ëŠ” ìƒí™©ì—ì„œ íŠ¹ì • êµ¬ì¡°ë¥¼ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•´ì•¼ í•˜ëŠ” ìƒí™©ì—ì„œ ìƒˆë¡œìš´ ë¦¬ì†ŒìŠ¤ì˜ ìƒì„±ì— ëŒ€í•œ ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì´ê¸° ìœ„í•´ ìºì‹±ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- í•˜ì§€ë§Œ ìºì‹±ì„ í•˜ê¸° ìœ„í•´ì„  í•¨ìˆ˜ ë°–ì— ìˆëŠ” ë³€ìˆ˜ì— ì•¡ì„¸ìŠ¤ í•´ì•¼ í•˜ë©° ê³µìœ ëœ ê°€ë³€ ìƒíƒœì— ì ‘ê·¼í•˜ê²Œ ë©ë‹ˆë‹¤.
    - ìŠ¤ë ˆë“œ ì•ˆì „ì„±, ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë“± ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œê°€ ë§ì•„ì§
- ê²°êµ­ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ëª©ì ì€ ë™ì‹œì„±ê³¼ ê°€ë³€ ìƒíƒœê°€ ë§Œë‚˜ëŠ” ìƒí™©ì„ ì—†ì• ëŠ” ê²ƒì´ì§€ë§Œ ìºì‹±ê³¼ ê°™ì€ ì €ìˆ˜ì¤€ ì„±ëŠ¥ ë¬¸ì œëŠ” í•´ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

<br>

### ê°™ì€ ê°ì²´ë¥¼ ë°˜í™˜í•¨ì˜ ì˜ë¯¸

`t2 = fupdate(â€Willâ€, 26, t);`

`t3 = fupdate(â€Willâ€, 26, t);`

ìœ„ì™€ ê°™ì€ ì½”ë“œì—ì„œ `t2 != t3`ëŠ” falseê°€ ë©ë‹ˆë‹¤.

ì¸ìˆ˜ê°€ ê°™ë‹¤ë©´ ê²°ê³¼ë„ ê°™ì•„ì•¼ í•˜ëŠ” ì°¸ì¡° íˆ¬ëª…ì„±ì´ ìœ„ë°°ëë‹¤ê³  ìƒê°í•  ìˆ˜ ìˆì§€ë§Œ, ì‹¤ì œë¡œëŠ” ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì°¸ì¡° íˆ¬ëª…ì„±ì—ì„œ ë§í•˜ëŠ” ê°™ì€ ê²°ê³¼ëŠ” ==ì˜ ì˜ë¯¸ê°€ ì•„ë‹ˆë¼ êµ¬ì¡°ì ì¸ ê°’ì´ ê°™ìŒì„ ì˜ë¯¸ í•©ë‹ˆë‹¤. ë”°ë¼ì„œ fupdateëŠ” ì°¸ì¡° íˆ¬ëª…ì„±ì„ ê°–ìŠµë‹ˆë‹¤.

<br>

### ì½¤ë¹„ë„¤ì´í„°

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œ ë§ì´ ì‚¬ìš©ë˜ëŠ” í˜•ì‹ì€ ë‘ í•¨ìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ë°›ê³  ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” ê³ ì°¨ì› í•¨ìˆ˜ë¥¼ ë§ì´ ì‚¬ìš©í•©ë‹ˆë‹¤.

Java 8 APIì— ì¶”ê°€ëœ ë§ì€ ê¸°ëŠ¥ì€ combinatorì˜ ì˜í–¥ì„ ë§ì´ ë°›ì•˜ìŠµë‹ˆë‹¤.

```java
// í•¨ìˆ˜ ì¡°í•© ì½”ë“œë“¤
static <A, B, C> Function<A, C> compose(Function<B, C> g, Function<A, B> f) {
    return x -> g.apply(f.apply(x));
}

static <A> Function<A, A> repeat(int n, Function<A, A> f) {
    return n == 0 ? x -> x : compose(f, repeat(n - 1, f));
}
```

ìœ„ì™€ ê°™ì´ ì‚¬ìš©í•˜ê²Œ ë˜ë©´ ë°˜ë³µ ê³¼ì •ì—ì„œ ì „ë‹¬ë˜ëŠ” ê°€ë³€ ìƒíƒœ í•¨ìˆ˜í˜• ëª¨ë¸ ë“± ë°˜ë³µ ê¸°ëŠ¥ì„ ì¢€ ë” ë‹¤ì–‘í•˜ê²Œ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<br><br>

## âœ…Â 19.6 ë§ˆì¹˜ë©°

- ì¼ê¸‰ í•¨ìˆ˜: ì¸ìˆ˜ ì „ë‹¬, ê²°ê³¼ ë°˜í™˜, ìë£Œêµ¬ì¡°ì— ì €ì¥ë  ìˆ˜ ìˆëŠ” í•¨ìˆ˜
- ê³ ì°¨ì› í•¨ìˆ˜: í•œ ê°œ ì´ìƒì˜ í•¨ìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ë°›ì•„ì„œ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
- ì»¤ë§: í•¨ìˆ˜ë¥¼ ëª¨ë“ˆí™” í•˜ê³  ì½”ë“œë¥¼ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ì§€ì›í•˜ëŠ” ê¸°ë²•
- ì˜ì† ìë£Œêµ¬ì¡°: ê°±ì‹ ë  ë•Œ ê¸°ì¡´ ë²„ì „ì¸ ìì‹ ì„ ë³´ì¡´í•¨
- íŒ¨í„´ ë§¤ì¹­: ìë£Œí˜•ì„ ì–¸ë©í•˜ëŠ” í•¨ìˆ˜í˜• ê¸°ëŠ¥
- ì½¤ë¹„ë„¤ì´í„°: ë‘˜ ì´ìƒì˜ í•¨ìˆ˜ë‚˜ ìë£Œêµ¬ì¡°ë¥¼ ì¡°í•©í•˜ëŠ” í•¨ìˆ˜í˜• ê°œë…

<br><br><br>

# ğŸ“ŒÂ 20ì¥: OOPì™€ FPì˜ ì¡°í™”: ìë°”ì™€ ìŠ¤ì¹¼ë¼ ë¹„êµ

- ìŠ¤ì¹¼ë¼: ê°ì²´ì§€í–¥ + í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ í˜¼í•©í•œ ì–¸ì–´

<br><br>

## âœ…Â 20.1 ìŠ¤ì¹¼ë¼ ì†Œê°œ

```scala
object Beer {

  def main(args: Array[String]) {
    imperative()
    functional()
  }

  def imperative() {
    var n: Int = 2
    while (n <= 6) {
      println(s"Hello ${n} bottles of beer")
      n += 1
    }
  }

  def functional() {
    2 to 6 foreach { n => println(s"Hello ${n} bottles of beer") }
  }

}
```

- ë¹„ì¬ê·€ ë©”ì„œë“œëŠ” ë°˜í™˜ í˜•ì‹ì„ ì¶”ë¡ í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ëª…ì‹œì ìœ¼ë¡œ ë°˜í™˜í˜•ì‹ì„ ì •ì˜í•˜ì§€ ì•Šì•„ë„ ë¨
- ìœ„ì˜ `object Beer`ë¡œ ì¸í•´ Beer í´ë˜ìŠ¤ ì •ì˜ ë° ì‹±ê¸€í„´ ì¸ìŠ¤í„´ìŠ¤ë¡œ ìƒì„±í•©ë‹ˆë‹¤. ë”°ë¼ì„œ object ë‚´ë¶€ì˜ ë©”ì„œë“œëŠ” ì •ì  ë©”ì„œë“œë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.

<br>

### ê¸°ë³¸ ìë£Œêµ¬ì¡°: ë¦¬ìŠ¤íŠ¸, ì§‘í•©, ë§µ, íŠœí”Œ, ìŠ¤íŠ¸ë¦¼, ì˜µì…˜

- ìŠ¤ì¹¼ë¼ëŠ” ë¶ˆë³€ ì»¬ë ‰ì…˜ ìì²´ë¥¼ ì œê³µí•¨
- ë”°ë¼ì„œ ê¸°ì¡´ ì»¬ë ‰ì…˜ì— ìƒˆë¡œìš´ ìš”ì†Œë¥¼ ì¶”ê°€í•˜ë©´ ìƒˆë¡œìš´ ì»¬ë ‰ì…˜ì´ ìƒì„±ë˜ì–´ ë°˜í™˜ë¨: `ì˜ì†ì„± ìœ ì§€`
- `scala.collection.mutable` íŒ¨í‚¤ì§€ì—ì„œ ê°€ë³€ ë²„ì „ì˜ ì»¬ë ‰ì…˜ë„ ì œê³µí•©ë‹ˆë‹¤.

**ìë°”ì˜ ë¶ˆë³€ ì»¬ë ‰ì…˜ê³¼ ìŠ¤ì¹¼ë¼ì˜ ë¶ˆë³€ ì»¬ë ‰ì…˜ì˜ ì°¨ì´**

```java
Set<Integer> numbers = ...;
Set<Integer> newNumbers = Collections.unmodifiableSet(numbers);
```

- ìë°”ë„ Collections.unmodifiableSet(numbers); ë¥¼ í†µí•´ ë¶ˆë³€ ì»¬ë ‰ì…˜ì„ ì œê³µí•©ë‹ˆë‹¤.
í•˜ì§€ë§Œ numbersë¼ëŠ” ì»¬ë ‰ì…˜ì— ê°’ì„ ì¶”ê°€í•˜ë©´ ìœ„ ë©”ì„œë“œë¡œ ë°˜í™˜ëœ ì»¬ë ‰ì…˜ì—ë„ ê°’ì´ ì¶”ê°€ë©ë‹ˆë‹¤.
- ì´ëŠ” í•´ë‹¹ ë©”ì„œë“œë¡œ ë°˜í™˜ë˜ëŠ” ì»¬ë ‰ì…˜ì´ ê°€ë³€ ì»¬ë ‰ì…˜ì˜ wrapper classì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
- ë°˜ë©´ì— ìŠ¤ì¹¼ë¼ì˜ ë¶ˆë³€ ì»¬ë ‰ì…˜ì€ ì–¼ë§ˆë‚˜ ë§ì€ ë³€ìˆ˜ê°€ í•´ë‹¹ ì»¬ë ‰ì…˜ì„ ì°¸ì¡°í•˜ëŠ”ì§€ì™€ ê´€ê³„ì—†ì´ ë¶ˆë³€ì„ ìœ ì§€í•©ë‹ˆë‹¤.

**íŠœí”Œì˜ ì œê³µ**

ìŠ¤ì¹¼ë¼ëŠ” tuple ìë£Œí˜•ì„ ì œê³µí•œë‹¤ëŠ” ì ì—ì„œ ìë°”ì™€ ì°¨ì´ì ì´ ìˆìŠµë‹ˆë‹¤.

**ìŠ¤ì¹¼ë¼ì˜ ìŠ¤íŠ¸ë¦¼**

ìë°”ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì§€ì—° í‰ê°€ë¥¼ í•˜ëŠ” ìŠ¤íŠ¸ë¦¼ì„ ì œê³µí•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì¸ë±ìŠ¤ë¥¼ ì œê³µí•˜ë¯€ë¡œ ì¸ë±ìŠ¤ë¥¼ í†µí•´ ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ ì ‘ê·¼í•  ìˆ˜ ìˆì–´ ìë°”ë³´ë‹¤ëŠ” ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì´ ì¡°ê¸ˆ ë–¨ì–´ì§‘ë‹ˆë‹¤. (ìºì‹±)

**ì˜µì…˜**

ìŠ¤ì¹¼ë¼ë„ nullì´ ì¡´ì¬í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ìë°”ì˜ Optionalê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

<br><br>

## âœ…Â 20.2 í•¨ìˆ˜

ìŠ¤ì¹¼ë¼ì˜ í•¨ìˆ˜ëŠ” ì–´ë–¤ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ì¼ë ¨ì˜ ëª…ë ¹ì–´ ê·¸ë£¹ì„ ë§í•©ë‹ˆë‹¤.

ìŠ¤ì¹¼ë¼ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

- `í•¨ìˆ˜ í˜•ì‹`: ìë°”ì˜ í•¨ìˆ˜ ë””ìŠ¤í¬ë¦½í„°ì˜ ê°œë…ì„ í‘œí˜„í•˜ëŠ” í¸ì˜ ë¬¸ë²•ì…ë‹ˆë‹¤.
- `ìµëª… í•¨ìˆ˜`: ìµëª… í•¨ìˆ˜ëŠ” ìë°”ì˜ ëŒë‹¤ì™€ ë‹¬ë¦¬ ë¹„ì§€ì—­ ë³€ìˆ˜ ì ‘ê·¼ ë° ê°’ ë³€ê²½ì— ì œí•œì´ ì—†ìŠµë‹ˆë‹¤.
- `ì»¤ë§ ì§€ì›`: ì»¤ë§ì„ ìì²´ì ì¸ ë¬¸ë²•ìœ¼ë¡œ ì§€ì›í•©ë‹ˆë‹¤. (ì—¬ëŸ¬ ì¸ìˆ˜ë¥¼ ë°›ëŠ” í•¨ìˆ˜ë¥¼ ì¼ë¶€ ì¸ìˆ˜ë¥¼ ë°›ëŠ” ì—¬ëŸ¬ê°œì˜ í•¨ìˆ˜ë¡œ ë¶„ë¦¬)

<br>

### ìŠ¤ì¹¼ë¼ì˜ ì¼ê¸‰ í•¨ìˆ˜

ìŠ¤ì¹¼ë¼ì˜ í•¨ìˆ˜ëŠ” ì¼ê¸‰ê°’ ì…ë‹ˆë‹¤.

```scala
object Tweets {

  def isJavaMentioned(tweet: String) : Boolean = tweet.contains("Java")
  def isShortTweet(tweet: String) : Boolean = tweet.length() < 20

  def main(args: Array[String]) {
    val tweets = List(
      "I love the new features in Java 8",
      "How's it going?",
      "An SQL query walks into a bar, sees two tables and says 'Can I join you?'"
    )

		// ìœ„ì˜ predicateë¥¼ í†µí•´ filtering ê°€ëŠ¥
    tweets.filter(isJavaMentioned).foreach(println)
    tweets.filter(isShortTweet).foreach(println)

    val isLongTweet : String => Boolean = (tweet : String) => tweet.length() > 60
    tweets.map(isLongTweet).foreach(println)
  }

}
```

filterì˜ ì‹œê·¸ë‹ˆì²˜ëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤. A ì¸ìë¥¼ ë°›ìœ¼ë©´ Booleanì„ ë°˜í™˜í•˜ëŠ”ê²ƒì„ ë¬¸ë²•ìœ¼ë¡œ ì œê³µí•©ë‹ˆë‹¤.

![image](https://github.com/Invincible-Backend-Study/modern-java-in-action/assets/66772624/cf83e5dd-3ecd-4095-adac-a7ebe5899c37)

<br>

### ìµëª… í•¨ìˆ˜ì™€ í´ë¡œì €

**ìµëª…í•¨ìˆ˜**

```scala
// ìµëª… í´ë˜ìŠ¤
val isLongTweet : String => Boolean = new Function1[String, Boolean] {
		def apply(tweet: String): Boolean = tweet.length() > 60
}

// ìµëª… í•¨ìˆ˜
val isLongTweet : String => Boolean = (tweet : String) => tweet.length() > 60
tweets.map(isLongTweet).foreach(println) // false
```

ìŠ¤ì¹¼ë¼ëŠ” ë³´í†µ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë“¯ applyë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¦‰ `f(a) â†’ f.apply(a)`ì™€ ê°™ì€ í˜¸ì¶œì´ ë©ë‹ˆë‹¤.

```scala
isLongTweet("A very short tweet") // isLongTweet.apply("A very short tweet")ê³¼ ë™ì¼
```

**í´ë¡œì €**

í•¨ìˆ˜ì˜ ë¹„ì§€ì—­ ë³€ìˆ˜ë¥¼ ììœ ë¡­ê²Œ ì°¸ì¡°í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§í•©ë‹ˆë‹¤.

```scala
object Closure {

  def main(args: Array[String]) {
    var count = 0
    val inc = () => count += 1
    inc()
    println(count) // 1
    inc()
    println(count) // 2
  }

}
```

ë°˜ë©´ì— ìë°”ëŠ” ì•„ë˜ì™€ ê°™ì€ ì½”ë“œê°€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.

```java
public static void main(String[] args) {
		int count = 0;
		Runnalbe inc = () -> count += 1; // ì—ì´ˆì— ì»´íŒŒì¼ ì—ëŸ¬
}
```

â†’ í´ë¡œì € ê¸°ëŠ¥ì€ ì •ë§ í•„ìš”í• ë•Œë§Œ ì‚¬ìš©í•˜ëŠ”ê²ƒì´ ë°”ëŒì§í•©ë‹ˆë‹¤.

<br>

### ì»¤ë§

ìŠ¤ì¹¼ë¼ëŠ” ì»¤ë§ì„ ë¬¸ë²•ì ìœ¼ë¡œ ì œê³µí•´ì¤ë‹ˆë‹¤.

```scala
object Currying {

  def main(args: Array[String]) {
    def multiply(x : Int, y: Int) = x * y
    val r1 = multiply(2, 10)
    println(r1)
		
		// 1ê°œì˜ íŒŒë¼ë¯¸í„°ë¥¼ ê°–ëŠ” ì¸ìˆ˜ë¦¬ìŠ¤íŠ¸ë¥¼ 2ê°œ ê°€ì§
    def multiplyCurry(x :Int)(y : Int) = x * y

		// ì»¤ë§í•œ í•¨ìˆ˜ì— í•œë²ˆì— ê°’ ëŒ€ì…
    val r2 = multiplyCurry(2)(10)
    println(r2) // 20
		

		// í•¨ìˆ˜ë¥¼ ë¶€ë¶„ì ìš©í•˜ì—¬ ì»¤ë§ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•¨
    val multiplyByTwo : Int => Int = multiplyCurry(2)
    val r3 = multiplyByTwo(10)
    println(r3) // 20
  }

}
```

<br><br>

## âœ…Â 20.3 í´ë˜ìŠ¤ì™€ íŠ¸ë ˆì´íŠ¸

### ìŠ¤ì¹¼ë¼ì˜ í´ë˜ìŠ¤

ìŠ¤ì¹¼ë¼ì˜ í´ë˜ìŠ¤ëŠ” getter, setter, ìƒì„±ìê°€ ì•”ì‹œì ìœ¼ë¡œ ìƒì„±ë˜ë¯€ë¡œ ì½”ë“œê°€ í›¨ì”¬ ë‹¨ìˆœí•´ì§‘ë‹ˆë‹¤.

```scala
class Student(var name: String, var id: Int)

	object Student {
	
	  def main(args: Array[String]) {
		    val s = new Student("Raoul", 1)
		    println(s.name) // Raoul
		    s.id = 1337
		    println(s.id) // 1337
	  }
}
```

<br>

### ìŠ¤ì¹¼ë¼ì˜ íŠ¸ë ˆì´íŠ¸

ìŠ¤ì¹¼ë¼ì˜ íŠ¸ë ˆì´íŠ¸ëŠ” ìë°”ì˜ ì¸í„°í˜ì´ìŠ¤ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ ì¶”ê°€ì ìœ¼ë¡œ í•„ë“œë„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë˜í•œ ì¸í„°í˜ì´ìŠ¤ì™€ ê°™ì´ ë‹¤ì¤‘ ìƒì†ë„ ì§€ì›í•©ë‹ˆë‹¤.

**íŠ¸ë ˆì´íŠ¸ ì„ ì–¸ ë° í´ë˜ìŠ¤ì™€ì˜ ì¡°í•©**

```scala
trait Sized {
  var size: Int = 0
  def isEmpty() = size == 0
}

object SizedRunner {
  def main(args: Array[String]) {
    class Empty extends Sized

    println(new Empty().isEmpty()) // true
  }
}
```

**ì¸ìŠ¤í„´ìŠ¤í™” ê³¼ì •ì—ì„œ íŠ¸ë ˆì´íŠ¸ ì¡°í•©(ì»´íŒŒì¼ì‹œ ì¡°í•©ê²°ê³¼ê°€ ê²°ì •ë¨)**

```scala
trait Sized {
  var size: Int = 0
  def isEmpty() = size == 0
}

object SizedRunner {

  def main(args: Array[String]) {
    class Box

    val b1 = new Box() with Sized // ì¸ìŠ¤í„´ìŠ¤í™”ì‹œ ì¡°í•©
    println(b1.isEmpty()) // true
  }

}
```

ê°™ì€ ì‹œê·¸ë‹ˆì²˜ì˜ ë©”ì„œë“œ í˜¹ì€ ê°™ì€ ì´ë¦„ì˜ í•„ë“œë¥¼ ì •ì˜í•˜ëŠ” íŠ¸ë ˆì´íŠ¸ë¥¼ ë‹¤ì¤‘ ìƒì†í•˜ë©´ ìë°”ì˜ ë””í´íŠ¸ ë©”ì„œë“œì—ì„œ ë¬¸ì œë¥¼ í•´ê²°í•œê²ƒê³¼ ë¹„ìŠ·í•˜ê²Œ ì œí•œì„ ë‘¡ë‹ˆë‹¤.
